#[derive(Deserialize, Debug)]
pub struct Issue {
    #[serde(rename="self")]
    pub self_link: String,
    pub key: String,
    pub id: u32,
    pub expand: String,
    pub fields: ::std::collections::HashMap<String, ::serde_json::Value>
}

impl Issue {
    pub fn field<F>(&self, name: &str) -> Option<Result<F>> where  F: Deserialize {
        self.fields.get(name).map(|value| {
            let decoded = try!(serde_json::value::from_value::<F>(value.clone()));
            Ok(decoded)
        })
    }

    fn user_field(&self, name: &str) -> Option<Result<User>> {
        self.field::<User>(name)
    }

    fn string_field(&self, name: &str) -> Option<Result<String>> {
        self.field::<String>(name)
    }

    pub fn assignee(&self) -> Option<User> {
        self.user_field("assignee").and_then(|value| value.ok())
    }

    pub fn creator(&self) -> Option<User> {
        self.user_field("creator").and_then(|value| value.ok())
    }

    pub fn reporter(&self) -> Option<User> {
        self.user_field("reporter").and_then(|value| value.ok())
    }

    pub fn status(&self) -> Option<Status> {
        self.field::<Status>("status").and_then(|value| value.ok())
    }

    pub fn summary(&self) -> Option<String> {
        self.string_field("summary").and_then(|value| value.ok())
    }

    pub fn description(&self) -> Option<String> {
        self.string_field("description").and_then(|value| value.ok())
    }

    pub fn updated(&self) -> Option<String> {
        self.string_field("updated").and_then(|value| value.ok())
    }

    pub fn created(&self) -> Option<String> {
        self.string_field("created").and_then(|value| value.ok())
    }

    pub fn issue_type(&self) -> Option<IssueType> {
        self.field::<IssueType>("issuetype").and_then(|value| value.ok())
    }

    pub fn labels(&self) -> Vec<String> {
        self.field::<Vec<String>>("labels").and_then(|value| value.ok()).unwrap_or(vec![])
    }

    pub fn fix_versions(&self) -> Vec<Version> {
        self.field::<Vec<Version>>("fixVersions").and_then(|value| value.ok()).unwrap_or(vec![])
    }
}

#[derive(Deserialize, Debug)]
pub struct Version {
    pub archived: bool,
    pub id: String,
    pub name: String,
    pub released: bool,
    #[serde(rename="self")]
    pub self_link: String,
}

#[derive(Deserialize, Debug)]
pub struct User {
    pub active: bool,
    #[serde(rename="avatarUrls")]
    pub avatar_urls: ::std::collections::HashMap<String, String>,
    #[serde(rename="displayName")]
    pub display_name: String,
    #[serde(rename="emailAddress")]
    pub email_address: String,
    pub key: String,
    pub name: String,
    #[serde(rename="self")]
    pub self_link: String,
    #[serde(rename="timeZone")]
    pub timezone: String,
}

#[derive(Deserialize, Debug)]
pub struct Status {
    pub description: String,
    #[serde(rename="iconUrl")]
    pub icon_url: String,
    pub id: String,
    pub name: String,
    #[serde(rename="self")]
    pub self_link: String,
}

#[derive(Deserialize, Debug)]
pub struct IssueType {
    pub description: String,
    #[serde(rename="iconUrl")]
    pub icon_url: String,
    pub id: String,
    pub name: String,
    #[serde(rename="self")]
    pub self_link: String,
    pub subtask: bool,
}

#[derive(Deserialize, Debug)]
pub struct SearchResults {
    pub total: u32,
    #[serde(rename="maxResults")]
    pub max_results: u32,
    #[serde(rename="startAt")]
    pub start_at: u32,
    pub expand: String,
    pub issues: Vec<Issue>
}
